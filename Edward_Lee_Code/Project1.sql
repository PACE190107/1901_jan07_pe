CREATE TABLE EMPLOYEE(
    EMPLOYEE_ID NUMBER PRIMARY KEY,
    FIRST_NAME VARCHAR2(20),
    LAST_NAME VARCHAR2(20),
    USER_NAME VARCHAR(20) unique not null,
    PASSWORD VARCHAR2(100),
    SALT VARCHAR2(20),
    EMAIL VARCHAR2(60),
    MANAGER NUMBER(1)
    );
    DESCRIBE EMPLOYEE;
    DROP TABLE EMPLOYEE;
    SELECT * FROM EMPLOYEE;

CREATE TABLE REIMBURSEMENT(
    REIMBURSEMENT_ID NUMBER PRIMARY KEY,
    EMPLOYEE_ID NUMBER REFERENCES EMPLOYEE(EMPLOYEE_ID),
    AMOUNT NUMBER CONSTRAINT CHECK_IS_POSITIVE CHECK(AMOUNT >0),
    SUBMIT_DATE TIMESTAMP,
    EXPENDITURE_DATE TIMESTAMP,
    APPROVED_DENIED NUMBER DEFAULT -1, -- -1 UNTIL APPROVED(1) DENIED(0)
    APPROVED_DATE TIMESTAMP DEFAULT NULL,
    APPROVED_BY NUMBER DEFAULT NULL,
    IMAGE blob DEFAULT NULL--research says it might be better store the path and put it in a folder
    );
    DROP TABLE REIMBURSEMENT;
    select * from reimbursement;
    
    
--SEQUENCES
CREATE SEQUENCE EMPLOYEE_ID_SEQUENCE
    MINVALUE 1
    START WITH 1
    INCREMENT BY 1
    CACHE 10;
drop sequence EMPLOYEE_ID_SEQUENCE;

--SEQUENCES
CREATE SEQUENCE REIMBURSEMENT_ID_SEQUENCE
    MINVALUE 100
    START WITH 100
    INCREMENT BY 1
    CACHE 10;
drop sequence REIMBURSEMENT_ID_SEQUENCE;

--EMPLOYEE PROCEDURES
CREATE OR REPLACE PROCEDURE NEW_EMPLOYEE(
    FIRST_NAME IN VARCHAR2, LAST_NAME IN VARCHAR2, USERNAME IN VARCHAR2, PASSWORD IN VARCHAR2, EMAIL IN VARCHAR2, RETURNED_USER OUT SYS_REFCURSOR)
    --step one is hash generate salt and hash the password
IS USERID NUMBER := EMPLOYEE_ID_SEQUENCE.NEXTVAL;
SALT VARCHAR2(20) := CREATE_SALT(1);
HASHED_PASSWORD VARCHAR(100) := GET_HASH(USERNAME, PASSWORD, SALT);
BEGIN
    INSERT INTO EMPLOYEE VALUES (USERID, FIRST_NAME, LAST_NAME, USERNAME, HASHED_PASSWORD, SALT, EMAIL, 0);
    GET_EMPLOYEE(USERID, RETURNED_USER);
END;
/

CREATE OR REPLACE PROCEDURE NEW_MANAGER(
    FIRST_NAME IN VARCHAR2, LAST_NAME IN VARCHAR2, USERNAME IN VARCHAR2, PASSWORD IN VARCHAR2, EMAIL IN VARCHAR2, RETURNED_USER OUT SYS_REFCURSOR)
    --step one is hash generate salt and hash the password
IS USERID NUMBER := EMPLOYEE_ID_SEQUENCE.NEXTVAL;
SALT VARCHAR2(20) := CREATE_SALT(1);
HASHED_PASSWORD VARCHAR(100) := GET_HASH(USERNAME, PASSWORD, SALT);
BEGIN
    INSERT INTO EMPLOYEE VALUES (USERID, FIRST_NAME, LAST_NAME, USERNAME, HASHED_PASSWORD, SALT, EMAIL, 1);
    GET_EMPLOYEE(USERID, RETURNED_USER);

END;
/

CREATE OR REPLACE PROCEDURE EDIT_EMPLOYEE
(INPUT_ID IN NUMBER, NEW_FIRST_NAME IN VARCHAR2, NEW_LAST_NAME IN VARCHAR2, NEW_EMAIL IN VARCHAR2, EDITED_EMPLOYEE OUT SYS_REFCURSOR)
IS
BEGIN
    UPDATE EMPLOYEE 
    SET FIRST_NAME = NEW_FIRST_NAME,
        LAST_NAME = NEW_LAST_NAME,
        EMAIL = NEW_EMAIL
    WHERE EMPLOYEE_ID = INPUT_ID;
    --update password hash since it uses username MIGHT GET CONVOLUTED
    --SELECT EMPLOYEE TO RETURN IT 
    GET_EMPLOYEE(INPUT_ID, EDITED_EMPLOYEE);
END;
/

CREATE OR REPLACE PROCEDURE LOGIN_CHECK( USER IN VARCHAR2, PASS IN VARCHAR2, RETURNED_EMPLOYEE OUT SYS_REFCURSOR)--hashes incoming password with stored salt and then compares it to the stored password
IS
IN_HASH VARCHAR2(100);
CURR_HASH VARCHAR2(100);
SALTY VARCHAR2(20);
BEGIN
    --get salt from the table
    --get hash using the salt
    --compare hash to the hash in the table
    SELECT SALT INTO SALTY FROM EMPLOYEE WHERE USER = USER_NAME;
    SELECT PASSWORD INTO CURR_HASH FROM EMPLOYEE WHERE USER = USER_NAME;
    IN_HASH := GET_HASH(USER, PASS, SALTY);
    IF IN_HASH = CURR_HASH THEN
        OPEN RETURNED_EMPLOYEE FOR SELECT
        EMPLOYEE_ID, FIRST_NAME, LAST_NAME,USER_NAME, EMAIL, MANAGER FROM EMPLOYEE WHERE USER = USER_NAME;
    END IF;
END;
/

CREATE OR REPLACE PROCEDURE GET_EMPLOYEE(ID_NUM IN NUMBER, WANTED_EMPLOYEE OUT SYS_REFCURSOR)
IS BEGIN
    OPEN WANTED_EMPLOYEE FOR SELECT
    EMPLOYEE_ID, FIRST_NAME, LAST_NAME, USER_NAME, EMAIL, MANAGER
    FROM EMPLOYEE
    WHERE EMPLOYEE_ID = ID_NUM;
END;
/


--REIMBURSEMENT PROCEDURES
CREATE OR REPLACE PROCEDURE NEW_REIMBURSEMENT
    (EMPL_ID IN NUMBER, IN_AMOUNT IN NUMBER, EXPENSE_DATE IN TIMESTAMP, R_OUT OUT SYS_REFCURSOR)
IS R_ID NUMBER := REIMBURSEMENT_ID_SEQUENCE.NEXTVAL;
CURR_TIME TIMESTAMP := CURRENT_DATE;
BEGIN
    INSERT INTO REIMBURSEMENT 
    (REIMBURSEMENT_ID, EMPLOYEE_ID, AMOUNT, SUBMIT_DATE, EXPENDITURE_DATE)
    VALUES(R_ID, EMPL_ID, IN_AMOUNT, CURR_TIME, EXPENSE_DATE);
    GET_REIMBURSEMENT(R_ID, R_OUT);
END;
/

CREATE OR REPLACE PROCEDURE APPROVE_REIMBURSEMENT(R_ID IN NUMBER, MAN_ID IN NUMBER, SUCCESS OUT SYS_REFCURSOR)
IS CURR_DATE TIMESTAMP:= CURRENT_DATE;
BEGIN
    UPDATE REIMBURSEMENT SET APPROVED_DENIED = 1, APPROVED_BY= MAN_ID, APPROVED_DATE = CURR_DATE WHERE R_ID = REIMBURSEMENT_ID;
    GET_REIMBURSEMENT(R_ID, SUCCESS);
END;
/

CREATE OR REPLACE PROCEDURE DENY_REIMBURSEMENT(R_ID IN NUMBER, MAN_ID IN NUMBER, SUCCESS OUT SYS_REFCURSOR)
IS CURR_DATE TIMESTAMP:= CURRENT_DATE;
BEGIN
    UPDATE REIMBURSEMENT SET APPROVED_DENIED = 0, APPROVED_BY= MAN_ID, APPROVED_DATE = CURR_DATE WHERE R_ID = REIMBURSEMENT_ID;
    GET_REIMBURSEMENT(R_ID, SUCCESS);
END;
/

CREATE OR REPLACE PROCEDURE GET_REIMBURSEMENT(R_ID IN NUMBER, R_OUT OUT SYS_REFCURSOR)
IS BEGIN 
    OPEN R_OUT FOR
    SELECT * FROM REIMBURSEMENT WHERE R_ID = REIMBURSEMENT_ID;
END;
/
    
CREATE OR REPLACE PROCEDURE GET_EMPLOYEE_REIMBURSEMENTS(E_USERNAME IN VARCHAR2, REIMBURSEMENTS OUT SYS_REFCURSOR)
IS BEGIN
    OPEN REIMBURSEMENTS FOR
    SELECT REIMBURSEMENT.REIMBURSEMENT_ID, EMPLOYEE.EMPLOYEE_ID, REIMBURSEMENT.AMOUNT, REIMBURSEMENT.SUBMIT_DATE, REIMBURSEMENT.EXPENDITURE_DATE,
    REIMBURSEMENT.APPROVED_DENIED, REIMBURSEMENT.APPROVED_DATE, REIMBURSEMENT.APPROVED_BY
    FROM REIMBURSEMENT INNER JOIN EMPLOYEE ON REIMBURSEMENT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID
    WHERE E_USERNAME = USER_NAME;
END;
/

CREATE OR REPLACE PROCEDURE GET_PENDING(PENDING OUT SYS_REFCURSOR)
IS BEGIN
    OPEN PENDING FOR
    SELECT REIMBURSEMENT_ID, EMPLOYEE_ID, AMOUNT, SUBMIT_DATE, EXPENDITURE_DATE
    FROM REIMBURSEMENT WHERE APPROVED_DENIED = -1;
END;
/
CREATE OR REPLACE PROCEDURE GET_RESOLVED(PENDING OUT SYS_REFCURSOR)
IS BEGIN
    OPEN PENDING FOR
    SELECT *
    FROM REIMBURSEMENT WHERE APPROVED_DENIED >-1;
END;
/

CREATE OR REPLACE FUNCTION CREATE_SALT(UNUSEDNUM NUMBER ) RETURN VARCHAR2
IS
BEGIN
RETURN DBMS_RANDOM.STRING('X',20);
END;
/

CREATE OR REPLACE FUNCTION GET_HASH(USERNAME VARCHAR2, PASSWORD VARCHAR2, SALT VARCHAR2) RETURN VARCHAR2
IS
BEGIN
  RETURN TO_CHAR(DBMS_OBFUSCATION_TOOLKIT.MD5(
  INPUT => UTL_I18N.STRING_TO_RAW(DATA => USERNAME || PASSWORD || SALT)));
END;
/
drop function GET_CUSTOMER_HASH;